<a id="cancellation-tokens" class="anchor"></a>
<h3>Cancellation token'ы</h3>

<p>
    Hangfire может сообщить вашим методам, что их обработка была завершена администратором или в случае остановки сервера. Таким образом, у вас есть возможность "вежливого" завершения методов, не дожидаясь исключения ThreadAbortedException.
</p>

{% highlight csharp %}
public void Method(IJobCancellationToken token)
{
    for (var i = 0; i < Int32.MaxValue; i++)
    {
        token.ThrowIfCancellationRequested();
        Thread.Sleep(1000);
    }
}
{% endhighlight %}

<a id="ioc-containers" class="anchor"></a>
<h3>Поддержка IoC-контейнеров</h3>

<p>
    Если вы хотите улучшить тестируемость ваших фоновых задач или просто не хотите использовать множество фабрик, просто начните использовать экземплярные методы.
</p>

<p>
    Чтобы иметь возможность передавать зависимости через параметры конструктора, вы можете использовать ваш любимый IoC контейнер, с помощью которого будут создаваться экземпляры классов, участвующих в фоновых задачах. Есть два пакета, Hangfire.Ninject и Hangfire.Autofac для своих контейнеров. Если вы используете другой контейнер, вы можете написать его сами (на основании данных пакетов) и способствовать развитию проекта Hangfire.
</p>

<a id="logging" class="anchor"></a>
<h3>Логирование</h3>

<p>
    Hangfire использует библиотеку Common.Logging для журналирования всех событий. Это общая библиотека, и вы можете подключить ее к вашей инфраструктуре с помощью специализированных адаптеров. Пожалуйста, смотрите список доступных адаптеров NuGet галерее.
</p>

<a id="web-garden-web-farm-support" class="anchor"></a>
<h3>Поддержка Web Garden и Web Farm</h3>

<p>
    Вы можете запускать несколько экземпляров Hangfire, на той же машине или на разных. Он использует распределенные блокировки для координирования экземпляров и предотвращения состояния гонки. Каждый экземпляр Hangfire является избыточным, и вы можете добавлять или удалять экземпляры в процессе работы.
</p>

<a id="multiple-queue-processing" class="anchor"></a>
<h3>Обработка нескольких очередей</h3>

<p>
    Hangfire может обрабатывать несколько очередей. Если вы хотите использовать приоритизацию задач или разделить обработку на разные серверы (некоторые процессы обслуживают очередь архивов, другие - очередь изображений, и т.д.), вы можете сообщить Hangfire о вашем решении.
</p>

<p>
    Чтобы поместить задачу в другую очередь, примените атрибут QueueAttribute к вашему методу:
</p>

{% highlight csharp %}
[Queue("critical")]
public void SomeMethod() { }

BackgroundJob.Enqueue(() => SomeMethod());
{% endhighlight %}

<p>
    Чтобы начать обрабатывать несколько очередей, вам необходимо обновить конфигурацию вашего класса OWIN Startup:
</p>

{% highlight csharp %}
app.UseHangfire(config =>
{
    config.UseServer("critical", "default");
});
{% endhighlight %}

<p>
    Порядок важен, здесь указано, что рабочие процессы будут получать задания сначала из критической очереди, а затем из очереди по умолчанию.
</p>

<a id="concurrency-level-control" class="anchor"></a>
<h3>Управление степенью параллелизма</h3>

<p>
    Hangfire использует свой ​​собственный фиксированный пул рабочих потоков для выполнения задач. По умолчанию размер пула установлен в Environment.ProcessorCount * 5. Это число – некоторый баланс между операциями с нагрузкой на процессор и операциями ввода / вывода интенсивных задач. Если у вас возникли чрезмерные ожидания или переключения контекста, вы можете настроить размер пула вручную:
</p>

{% highlight csharp %}
app.UseHangfire(config =>
{
    config.UseServer(100);
});

// or
var server = new BackgroundJobServer(100);
{% endhighlight %}

<a id="process-jobs-anywhere" class="anchor"></a>
<h3>Обработка задач в любом приложении</h3>

<p>
    По умолчанию, обработка заданий производится в приложении ASP.NET. Но вы можете обрабатывать задачи в консольном приложении, службе Windows или в любом другом месте.
</p>

<a id="extensibility" class="anchor"></a>
<h3>Расширяемость</h3>

<p>
    Hangfire построен для максимальной расширяемости. Вы можете расширить следующие детали:
</p>

<ul>
    <li>реализация хранилища;</li>
    <li>подсистема состояний (включая создание новых состояний);</li>
    <li>процесс создания задачи;</li>
    <li>процесс выполнения задачи;</li>
    <li>процесс изменения состояний;</li>
    <li>процесс активации задач.</li>
</ul>

<p>
    Некоторые из основных компонентов выполнены в виде расширений: QueueAttribute, PreserveCultureAttribute, AutomaticRetryAttribute, SqlServerStorage, RedisStorage, NinjectJobActivator, AutofacJobActivator, ScheduledState.
</p>