<a id="queue-based-processing" class="anchor"></a>
<h3>Обработка на основе очередей</h3>

<p>
    Вместо синхронного вызова метода, поместите его в очередь с постоянным хранением, и рабочий поток Hangfire начнет его выполнение:
</p>

{% highlight csharp %}
BackgroundJob.Enqueue(() => Console.WriteLine("Hello, world!"));
{% endhighlight %}

<p>
    Этот метод создает задачу, сохраняет ее в постоянном хранилище и возвращет управление вызывающему коду немедленно, без непосредственного выполнения. Hangfire гарантирует, что указанный метод будет вызван даже после аварийного завершения процесса.
</p>

<a id="delayed-method-invocation" class="anchor"></a>
<h3>Отложенный вызов метода</h3>

<p>
    Вы также можете отложить вызов метода на определенное время:
</p>

{% highlight csharp %}
BackgroundJob.Schedule(() => Console.WriteLine("Hello, world!"), TimeSpan.FromMinutes(5));
{% endhighlight %}

<p>
    Вызов данного метода так же сохраняет задачу, но, вместо того, чтобы помещать его в очередь, он добавляет задачу в расписание. Когда подойдет нужное время, задача будет добавлена в очередь.
</p>

<a id="recurring-tasks" class="anchor"></a>
<h3>Задачи по расписанию</h3>

<p>
    Обработка периодических задач никогда не была такой простой. Все, что вам нужно, это написать всего одну строчку кода:
</p>

{% highlight csharp %}
RecurringJob.AddOrUpdate(() => Console.Write("Easy!"), Cron.Daily);
{% endhighlight %}

<p>
    Hangfire использует библиотеку NCrontab для обработки расписания, так что вы можете использовать более сложные выражения Cron:
</p>

{% highlight csharp %}
RecurringJob.AddOrUpdate(() => Console.Write("Powerful!"), "0 12 * */2");
{% endhighlight %}

<a id="integrated-web-interface" class="anchor"></a>
<h3>Интегрированный веб-интерфейс</h3>

<p>
    Веб-интерфейс поможет вам отслеживать выполнение заданий: смотреть их состояние обработки, статистику и т.д. Посмотрите на скриншоты на http://hangfire.io, и вы его полюбите.
</p>

<a id="sql-redis-support" class="anchor"></a>
<h3>Поддержка SQL Server и Redis</h3>

<p>
    Hangfire использует постоянное хранилище для задач, очередей и статистики, что позволяет им выживать после перезапуска пула приложения. Подсистема хранения достаточно абстрагирована, чтобы поддерживать как классический SQL Server, так и удивительно быстрый Redis.
</p>

<ul>
    <li>SQL Server предоставляет упрощенную установку.</li>
    <li>Redis предоставляет внушительную скорость обработки, особенно по сравнению с SQL Server, но требует дополнительных знаний.</li>
</ul>

<a id="automatic-retries" class="anchor"></a>
<h3>Автоматический повтор задач</h3>

<p>
    Если во время выполнения метода произошло исключение, не волнуйтесь - задача будет повторена автоматически в течение нескольких секунд. Если все повторные попытки будут исчерпаны, вы сможете перезапустить ее вручную из интегрированного веб-интерфейса.
</p>

<p>
    Вы также можете управлять поведением механизма повторов с помощью класса AutomaticRetryAttribute. Просто примените его к своему методу, чтобы задать максимальное количество попыток:
</p>

{% highlight csharp %}
[AutomaticRetry(100)]
public static void GenerateStatistics() { }

BackgroundJob.Enqueue(() => GenerateStatistics());
{% endhighlight %}

<a id="guaranteed-processing" class="anchor"></a>
<h3>Гарантированная обработка</h3>

<p>
    Hangfire был написан с осознанием того, что родительский процесс может быть аварийно завершен на любой строке исполнения. Например, задача не удаляется, пока она не была выполнена.
</p>

<a id="instance-method-calls" class="anchor"></a>
<h3>Вызов экземплярных методов</h3>

<p>
    Все приведенные выше примеры использует вызов статических методов, однако экземплярные методы также поддерживаются:
</p>

{% highlight csharp %}
public class EmailService
{
    public void Send() { }
}

BackgroundJob.Enqueue<EmailService>(x => x.Send());
{% endhighlight %}

<p>
    Когда рабочий поток видит, что метод является экземплярным, то перед его вызовом создается экземпляр класса. По умолчанию используется метод Activator.CreateInstace, так что без дополнительной настройки поддерживаются только классы с конструкторами по умолчанию. Но вы можете подключить свой IoC контейнер, чтобы иметь возможность передачи необхоимых зависимостей через конструктор.
</p>

<a id="culture-capturing" class="anchor"></a>
<h3>Захват CurrentCulture</h3>

<p>
    Hangfire автоматически захватывает текущую культуру при создании задачи, и подставляет ее при выполнении в другом потоке. Эта работа производится с помощью класса CaptureCultureAttribute, который автоматически применяется ко всем фоновым задачам.
</p>